/* The consumer code that consumes the work items generated by the producer. 
 *
 * Author: Naga Kandasamy
 * Date created: August 6, 2018
 *
 * Last edited by:
 * William Anderson, 8/23/2018
 *
 * Compile as follows: 
 * gcc -o consumer consumer.c -std=c99 -Wall 
 *
 * */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <stdbool.h>
#include "buffer.h"

static bool VERBOSE = false;
static volatile int client_id;  /* Use the PID of the client as the ID */

void initialize_sems()
{
    sem_1 = sem_open (sem_1_name, 0);
    if (sem_1 == SEM_FAILED)
    {
        perror ("sem_open");
        exit (EXIT_FAILURE);
    }

    sem_2 = sem_open (sem_2_name, 0);
    if (sem_2 == SEM_FAILED)
    {
        perror ("sem_open");
        exit (EXIT_FAILURE);
    }

    sem_3 = sem_open (sem_3_name, 0);
    if (sem_3 == SEM_FAILED)
    {
        perror ("sem_open");
        exit (EXIT_FAILURE);
    }
}

void lock_shared_mem()
{
	if (VERBOSE)
	{
		printf("Client %d: lock_shared_mem() - locking shared memory\n", client_id);
	}

	// shared memory access  wait
	if (sem_wait(sem_3) == -1)
	{
        perror ("sem_wait");
        exit (EXIT_FAILURE);
	}
}

void unlock_shared_mem()
{
	if (VERBOSE)
	{
		printf("Client %d: unlock_shared_mem() - releasing shared memory\n", client_id);
	}

	// shared memory access post
	if (sem_post(sem_3) == -1)
	{
        perror ("sem_wait");
        exit (EXIT_FAILURE);
	}
}

void wait_for_producer()
{
    if (VERBOSE)
    {
    	printf("Client %d: wait_for_producer()\n", client_id);
    }

	/* Perform the probe operation on sem_2
     * i.e. wait until signaled by the producer */
    if (sem_wait (sem_2) == -1) {
        perror ("sem_wait");
        exit (EXIT_FAILURE);
    }
}

void signal_producer()
{
    if (VERBOSE)
    {
    	printf("Client %d: signal_producer()\n", client_id);
    }

	// post(sem_1): signal the producer that item has been consumed
	if (sem_post (sem_1) == -1)
	{
		perror("sem_post");
		exit(EXIT_FAILURE);
	}
}

int main (int argc, char **argv)
{
    int num_items_consumed = 0;
    int fd;
    buffer* mem_shared_buffer;
    int consumed_value;
    bool finished;

    client_id = getpid();

    /* Open the shared memory object previously created by the producer. */
    fd = shm_open (SHARED_OBJECT_PATH, O_RDWR, S_IRWXU | S_IRWXG);
    if (fd < 0) {
        perror ("shm_open");
        exit (EXIT_FAILURE);
    }
    if (VERBOSE)
    	printf ("Opened shared memory object %s\n", SHARED_OBJECT_PATH);

    /* Request the shared segment using mmap() */
    mem_shared_buffer = (buffer *) mmap (NULL, SIZE_OF_SHARED_MEMORY, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mem_shared_buffer == NULL) {
        perror ("mmap");
        exit (EXIT_FAILURE);
    }
    if (VERBOSE)
    	printf ("Shared memory segment allocated correctly (%d bytes).\n", (int)SIZE_OF_SHARED_MEMORY);

    /* Access the semaphores previously created by the producer. */

    initialize_sems();

    /* Stay in the while loop, consuming work items until finished */
    while (!finished)
    {
        /* Check if finished */
        /* Memory lock */
        lock_shared_mem();

        finished = mem_shared_buffer->is_finished;

        /* Memory unlock */
        unlock_shared_mem();

        if (finished)
        	break;

        /* Wait for the producer to signal that it has created work */
        wait_for_producer();

        /* Consume work item */
        /* Memory lock */
        lock_shared_mem();

        consumed_value = mem_shared_buffer->work[mem_shared_buffer->out];
        (mem_shared_buffer->out)--;
        (mem_shared_buffer->in)--;
        num_items_consumed++;

        /* If the buffer was full, signal the producer and change the is_full flag */
        if (mem_shared_buffer->is_full)
        {
			mem_shared_buffer->is_full = false;
			signal_producer();
        }

        /* Memory unlock */
        unlock_shared_mem();

        /* Report consumed item, simulate work */
        printf("Client %d: consumed item, working for %d sec\n", client_id, consumed_value);
        sleep(consumed_value);

    }

    printf ("Client %d: consumed %d work items\n", client_id, num_items_consumed);
           
    exit (EXIT_SUCCESS);
}
